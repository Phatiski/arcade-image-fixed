{"entries":[{"timestamp":1770987831893,"editorVersion":"2.0.63","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":157,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":0,"diffs":[[1," "]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":36,"length1":126,"diffs":[[1,"    \"description\": \"\",\n"]]},{"start1":188,"length1":68,"diffs":[[1,"        \"assets.json\"\n"]]},{"start1":217,"length1":75,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"},{"type":"added","filename":"fximg.ts","value":"\n/**\n * @author Phatiski NaphatManeenil(Phat)\n * fixed image manager\n */\n//% block=\"fixed image\" color=\"#18EC97\" icon=\"\\uf03e\"\nnamespace fximges { }\n\n//% blockNamespace=\"fximges\"\nnamespace fximg {\n\n    //               fximg/fxpic structure as buffer\n    //\n    //            header metadata layout (bit6 -> bit1)\n    //\n    //              |header|width  |height |length |\n    //              |      |b6 - b5|b4 - b3|b2 - b1|\n    //              |------|-------|-------|-------|\n    //              |0b00  |Uint8  |Uint8  |Uint8  |\n    //              |0b01  |Uint16 |Uint16 |Uint16 |\n    //              |0b10  |Uint32 |Uint32 |Uint32 |\n    //              |0b11  |Null   |Null   |Null   |\n    //\n    //                         flag header \n    //               [ bit8 = read-only mode       ]\n    //               [ bit7 = metadata-frozen mode ]\n    //\n    // fximg pixel-data -> 1nibble per 1pixel (1-16 index color)\n    // \n    //                       data structure\n    // \n    //                 [ byte1     = header     ]\n    //                 [ byte1>2>4 = width      ]\n    //                 [ byte1>2>4 = height     ]\n    //                 [ byte1>2>4 = length     ]\n    //                 [ byte1<n   = nibblePixel]\n\n    //% blockId=fximg_size_dimension block=\"$fxpic $dimension\"\n    //% fxpic.shadow=variables_get fxpic.defl=fxpicture\n    export function dimensionOf(fxpic: Buffer, dimension: image.Dimension): number { return helper.fximgDimensionOf(fxpic, dimension); };\n\n    export function widthOf(fxpic: Buffer): number { return helper.fximgWidthOf(fxpic); };\n\n    export function heightOf(fxpic: Buffer): number { return helper.fximgHeightOf(fxpic); };\n\n    //% blockId=fximg_size_length block=\"length of $fxpic\"\n    //% fxpic.shadow=variables_get fxpic.defl=fxpicture\n    export function lengthOf(fxpic: Buffer): number { return helper.fximgLengthOf(fxpic); };\n\n    /** */\n    //% blockId=fximg_create_frame block=\"create image frame| width $width height $height length $length\"\n    //% blockSetVariable=fxpictures\n    //% group=\"create\"\n    export function createFrame(width: number, height: number, length: number): Buffer { return helper.fximgCreateFrame(width, height, length); };\n\n    /** */\n    //% blockId=fximg_create block=\"create image| width $width height $height\"\n    //% blockSetVariable=fxpicture\n    //% group=\"create\"\n    export function create(width: number, height: number): Buffer { return helper.fximgCreate(width, height); };\n\n    /** */\n    //% blockId=fximg_from_image block=\"$pic=image_picker to fximage\"\n    //% group=\"import\"\n    export function fromImage(pic: Image): Buffer { return helper.fximgFromImage(pic); };\n\n    /** */\n    //% blockId=fximg_to_image block=\"$fxpic to image\"\n    //% fxpic.shadow=variables_get fxpic.defl=fxpicture\n    //% group=\"export\"\n    export function toImage(fxpic: Buffer): Image { return helper.fximgToImage(fxpic); };\n\n    //% blockId=fximg_from_frame block=\"$pics=lists_create_with to fxframe\"\n    //% pics.defl=image_picker\n    //% group=\"import\"\n    export function fromFrame(pics: Image[]): Buffer { return helper.fximgFromFrame(pics); };\n\n    //% blockId=fximg_to_frame block=\"$fxpics to frame\"\n    //% fxpics.shadow=variables_get fxpics.defl=fxpictures\n    //% group=\"export\"\n    export function toFrame(fxpics: Buffer): Image[] { return helper.fximgToFrame(fxpics); };\n\n    //% blockId=fximg_get_frame block=\"get $fxpics at $idx\"\n    //% fxpics.shadow=variables_get fxpics.defl=fxpictures\n    export function getFrame(fxpics: Buffer, idx: number): Buffer { return helper.fximgGetFrame(fxpics, idx); };\n\n    //% blockId=fximg_set_frame block=\"set $fxpics at $idx to $fxpic\"\n    //% fxpics.shadow=variables_get fxpics.defl=fxpictures\n    //% fxpic.shadow=variables_get fxpic.defl=fxpicture\n    export function setFrame(fxpics: Buffer, idx: number, fxpic: Buffer): void { helper.fximgSetFrame(fxpics, idx, fxpic); };\n\n    //% blockId=fximg_set_pixel block=\"set $fxpic at x $x y $y to $color=colorindexpicker\"\n    //% fxpic.shadow=variables_get fxpic.defl=fxpicture\n    export function setPixel(fxpic: Buffer, x: number, y: number, color: number): void { helper.fximgSetPixel(fxpic, x, y, color); };\n\n    //% blockId=fximg_get_pixel block=\"get $fxpic at x $x y $y\"\n    //% fxpic.shadow=variables_get fxpic.defl=fxpicture\n    export function getPixel(fxpic: Buffer, x: number, y: number): number { return helper.fximgGetPixel(fxpic, x, y); };\n\n    export function setRows(fxpic: Buffer, x: number, buf: Buffer, h?: number): void { helper.fximgSetRows(fxpic, x, buf, h); };\n\n    export function getRows(fxpic: Buffer, x: number, buf: Buffer, h?: number): void { helper.fximgGetRows(fxpic, x, buf, h); };\n}\n\n"},{"type":"added","filename":"fximg-utils.ts","value":"\nenum FximgDataIdx {\n    width = 0x0,\n    height = 0x1,\n    length = 0x2,\n    start = 0x3,\n}\n\nnamespace helper {\n\n    const fximgDataStr = {\n        0x0: `width`,\n        0x1: `height`,\n        0x2: `length`,\n        0x3: `start`,\n    };\n\n    export const fximgPos2idx = (a: number, amax: number, b: number) => (a * amax) + b;\n    export const fximgIsOutOfRange = (n: number, r: number) => (n < 0 || n >= r);\n    export const fximgIsOutOfArea = (x: number, y: number, w: number, h: number) => (fximgIsOutOfRange(x, w) || fximgIsOutOfRange(y, h));\n    export const fximgIsOutOfAreas = (pos: { x: number, y: number }[], w: number, h: number) => pos.every(v => (fximgIsOutOfArea(v.x, v.y, w, h)));\n    export const fximgIsEmptyImage = (img: Image) => img.equals(image.create(img.width, img.height));\n\n    // อ่าน flag\n    export function fximgIsReadonly(fximg: Buffer): boolean {\n        if (fximg.length < 1) return false;\n        return (fximg[0] & 0b10000000) !== 0;  // bit7\n    }\n\n    export function fximgIsMetadataFrozen(fximg: Buffer): boolean {\n        if (fximg.length < 1) return false;\n        return (fximg[0] & 0b01000000) !== 0;  // bit6\n    }\n\n    // ตั้ง flag (แต่ต้องเช็คก่อนว่าอนุญาตไหม)\n    export function fximgSetReadonly(fximg: Buffer, value: boolean) {\n        if (fximgIsMetadataFrozen(fximg)) return; // ห้ามแก้ถ้า freeze\n        if (value) fximg[0] |= 0b10000000;\n        else fximg[0] &= ~0b10000000;\n    }\n\n    export function fximgSetMetadataFrozen(fximg: Buffer, value: boolean) {\n        //if (fximgIsReadonly(fximg)) return; // ถ้า readonly แล้ว ห้าม set flag อื่น\n        if (value) fximg[0] |= 0b01000000;\n        else fximg[0] &= ~0b01000000;\n    }\n\n    export function fximgGetOffset(header: number, idxType: FximgDataIdx) {\n        if (idxType < 0x0 || idxType > 0x3) return { idx: -1, b2: -1 }\n        header &= 0xff;\n        let idx = 1, b2 = 0;\n        if (idxType >= 0x0) {\n            b2 = (header >> 4);\n            b2 &= 0x3;\n            if (idxType > 0x0) idx += (1 << b2);\n        }\n        if (idxType >= 0x1) {\n            b2 = (header >> 2);\n            b2 &= 0x3;\n            if (idxType > 0x1) idx += (1 << b2);\n        }\n        if (idxType >= 0x2) {\n            b2 = (header);\n            b2 &= 0x3;\n            if (idxType > 0x2) idx += (1 << b2);\n        }\n        return { idx: idx, b2: b2 }\n    }\n    export function fximgStartIndex(fximg: Buffer) {\n        return fximgGetOffset(fximg[0], 0x3).idx;\n    }\n    export function fximgSetData(fximg: Buffer, dataType: FximgDataIdx, v: number) {\n        if (fximgIsMetadataFrozen(fximg)) {\n            throw `this ${fximgDataStr[dataType]} is read only`\n            return;\n        }\n        if (dataType >= 0x3) return;\n        const { idx, b2 } = fximgGetOffset(fximg[0], dataType);\n        if (idx < 0 || b2 < 0) return;\n        if (b2 === 0x2) {\n            if (v > 0xffffffff) v = 0xffffffff;\n            fximg.setNumber(NumberFormat.UInt32LE, idx, v);\n        } else if (b2 === 0x1) {\n            if (v > 0xffff) v = 0xffff;\n            fximg.setNumber(NumberFormat.UInt16LE, idx, v);\n        } else if (b2 === 0x0) {\n            if (v > 0xff) v = 0xff;\n            fximg.setNumber(NumberFormat.UInt8LE, idx, v);\n        }\n    }\n    export function fximgGetData(fximg: Buffer, dataType: FximgDataIdx) {\n        const { idx, b2 } = fximgGetOffset(fximg[0], dataType);\n        if (idx < 0 || b2 < 0) return -1;\n        if (dataType >= 0x3) return idx;\n        if (b2 >= 0x3) return -1;\n        if (b2 >= 0x2) return fximg.getNumber(NumberFormat.UInt32LE, idx);\n        if (b2 >= 0x1) return fximg.getNumber(NumberFormat.UInt16LE, idx);\n        return fximg.getNumber(NumberFormat.UInt8LE, idx);\n    }\n\n    export function fximgWidthOf(fximg: Buffer) {\n        if (fximg.length < 1) return 0;\n        return fximgGetData(fximg, 0x0);\n    }\n    export function fximgHeightOf(fximg: Buffer) {\n        if (fximg.length < 1) return 0;\n        return fximgGetData(fximg, 0x1);\n    }\n    export function fximgLengthOf(fximg: Buffer) {\n        if (fximg.length < 5) return 0;\n        return fximgGetData(fximg, 0x2);\n    }\n    export function fximgDimensionOf(fximg: Buffer, d: image.Dimension) {\n        switch (d) {\n            case image.Dimension.Width: return fximgWidthOf(fximg);\n            case image.Dimension.Height: return fximgHeightOf(fximg);\n        } return 0;\n    }\n\n    function fximgInitFximgData(width: number, height: number, length: number) {\n        if (width > 0xffffffff) width = 0xffffffff; if (height > 0xffffffff) height = 0xffffffff; if (length > 0xffffffff) length = 0xffffffff;\n        let header = 0b00000000, ws = 0, hs = 0, ls = 0;\n        if (width > 0xff) ws++;\n        if (width > 0xffff) ws++;\n        //if (ws < 0x0 || ws > 0x3) ws &= 0x3;\n        if (ws > 0x0) header += (ws << 4);\n        if (height > 0xff) hs++;\n        if (height > 0xffff) hs++;\n        //if (hs < 0x0 || hs > 0x3) hs &= 0x3;\n        if (hs > 0x0) header += (hs << 2);\n        if (length > 0xff) ls++;\n        if (length > 0xffff) ls++;\n        //if (ls < 0x0 || ls > 0x3) ls &= 0x3;\n        if (ls > 0x0) header += (ls);\n        const mdata = { header: header, ws, hs, ls, mds: 1 };\n        mdata.mds += (1 << ws);\n        mdata.mds += (1 << hs);\n        mdata.mds += (1 << ls);\n        return mdata;\n    }\n\n    export function fximgCreateFrame(width: number, height: number, length: number): Buffer {\n        if (!length) length = 1;\n        const mdata = fximgInitFximgData(width, height, length)\n        const fximg = pins.createBuffer(mdata.mds + ((1 + (width * height * length)) >>> 1));\n        fximg[0] = mdata.header;\n        fximgSetData(fximg, 0x0, width);\n        fximgSetData(fximg, 0x1, height);\n        fximgSetData(fximg, 0x2, length);\n        fximgSetMetadataFrozen(fximg, true);\n        return fximg;\n    }\n\n    export function fximgCreate(width: number, height: number): Buffer {\n        return fximgCreateFrame(width, height, 1);\n    }\n\n    export function fximgFromImage(pic: Image): Buffer {\n        const fxpic = fximgCreate(pic.width, pic.height);\n        if (fximgIsEmptyImage(pic)) return fxpic;\n        const h = pic.height\n        const buf = pins.createBuffer(h);\n        for (let x = 0; x < pic.width; x++) {\n            pic.getRows(x, buf);\n            fximgSetRows(fxpic, x, buf, h);\n        }\n        return fxpic;\n    }\n\n    export function fximgToImage(fxpic: Buffer): Image {\n        const pic = image.create(fximgWidthOf(fxpic), fximgHeightOf(fxpic));\n        const h = pic.height;\n        const buf = pins.createBuffer(h);\n        for (let x = 0; x < pic.width; x++) {\n            fximgGetRows(fxpic, x, buf, h);\n            pic.setRows(x, buf);\n        }\n        return pic.clone();\n    }\n\n    const fximgMaxImgSizes = (pics: Image[]) => {\n        const cur = { width: pics[0].width, height: pics[0].height, area: 0, empty: 0 };\n        for (const pic of pics) {\n            cur.width = Math.max(cur.width, pic.width),\n                cur.height = Math.max(cur.height, pic.height);\n            if (fximgIsEmptyImage(pic)) cur.empty++;\n        }\n        cur.area = cur.width * cur.height;\n        return cur\n    }\n\n    export function fximgFromFrame(pics: Image[]): Buffer {\n        const allSize = fximgMaxImgSizes(pics);\n        const fxpics = fximgCreateFrame(allSize.width, allSize.height, pics.length);\n        if (allSize.empty >= pics.length) return fxpics;\n        const h = allSize.height;\n        const buf = pins.createBuffer(h);\n        let nw = 0;\n        for (const pic of pics) {\n            const _buf = pins.createBuffer(pic.height)\n            const sx = (allSize.width === pic.width ? 0 : (allSize.width - pic.width) >>> 1),\n                sy = (allSize.height === pic.height ? 0 : (allSize.height - pic.height) >>> 1);\n            for (let x = 0; x < pic.width; x++) {\n                pic.getRows(x, _buf);\n                buf.write(sy, _buf);\n                fximgSetRows(fxpics, nw + x + sx, buf, h)\n            }\n            buf.fill(0);\n            nw += allSize.width;\n        }\n        return fxpics;\n    }\n\n    export function fximgToFrame(fxpics: Buffer): Image[] {\n        const pics: Image[] = []\n        const pic = image.create(fximgWidthOf(fxpics), fximgHeightOf(fxpics));\n        const h = pic.height;\n        const buf = pins.createBuffer(h);\n        const startIdx = fximgStartIndex(fxpics);\n        for (let nw = 0; (((1 + (nw * pic.height)) >> 1) + startIdx) < fxpics.length; nw += pic.width) {\n            for (let x = 0; x < pic.width; x++) {\n                fximgGetRows(fxpics, nw + x, buf, h);\n                pic.setRows(x, buf);\n            }\n            pics.push(pic.clone())\n        }\n        return pics.slice();\n    }\n\n    export function fximgGetFrame(fxpics: Buffer, idx: number) {\n        const w = fximgWidthOf(fxpics);\n        const h = fximgHeightOf(fxpics);\n        const fxpic = fximgCreate(w, h);\n        const idxw = idx * w;\n        const tbuf = pins.createBuffer(h);\n        for (let x = 0; x < w; x++) {\n            fximgGetRows(fxpics, x + idxw, tbuf, h);\n            fximgSetRows(fxpic, x, tbuf, h);\n        }\n        return fxpic.slice();\n    }\n\n    export function fximgSetFrame(fxpics: Buffer, idx: number, fxpic: Buffer) {\n        const fw = fximgWidthOf(fxpics), fh = fximgHeightOf(fxpics);\n        const vw = fximgWidthOf(fxpic), vh = fximgHeightOf(fxpic);\n        const idxw = idx * fw;\n        const buf = pins.createBuffer(fh);\n        const _buf = pins.createBuffer(vh)\n        const sx = (fw === vw ? 0 : (fw - vw) >>> 1),\n            sy = (fh === vh ? 0 : (fh - vh) >>> 1);\n        for (let x = 0; x < vw; x++) {\n            fximgGetRows(fxpic, x, _buf, vh);\n            buf.write(sy, _buf);\n            fximgSetRows(fxpics, idxw + x + sx, buf, fh)\n        }\n    }\n\n    export function fximgSetPixel(fxpic: Buffer, x: number, y: number, color: number, idx?: number) {\n        if (fximgIsOutOfArea(x, y, fximgWidthOf(fxpic), fximgHeightOf(fxpic))) return;\n        idx = idx || 0; idx *= fximgWidthOf(fxpic)\n        color &= 0xf;\n        const i = fximgPos2idx(x + idx, fximgHeightOf(fxpic), y);\n        const ih4 = (i >>> 1) + fximgStartIndex(fxpic);\n        const curv = fxpic[ih4]\n        let nib0 = curv & 0xf,\n            nib1 = curv >>> 4;\n        if (i & 1 ? nib0 === color : nib1 === color) return;\n        if (i & 1) nib0 = color;\n        else nib1 = color;\n        fxpic[ih4] = (nib1 << 4) + nib0;\n    }\n\n    export function fximgGetPixel(fxpic: Buffer, x: number, y: number, idx?: number) {\n        if (fximgIsOutOfArea(x, y, fximgWidthOf(fxpic), fximgHeightOf(fxpic))) return 0;\n        idx = idx || 0; idx *= fximgWidthOf(fxpic);\n        const i = fximgPos2idx(x + idx, fximgHeightOf(fxpic), y);\n        const ih = i >>> 1;\n        const ih4 = ih + fximgStartIndex(fxpic);\n        const curv = fxpic[ih4];\n        return (i & 1 ? curv & 0xf : curv >>> 4)\n    }\n\n    export function fximgSetRows(fxpic: Buffer, x: number, src: Buffer, h?: number) {\n        h = h || fximgHeightOf(fxpic);\n        const len = Math.min(src.length, h);\n        if (len <= 0 || fximgIsOutOfRange(x, fximgWidthOf(fxpic) * fximgLengthOf(fxpic))) return;\n\n        const start = fximgStartIndex(fxpic);\n        const colStartBit = (x * h) & 1;   // 0 = even (aligned), 1 = odd (misaligned)\n        const pixelCount = len;\n\n        let srcIdx = 0;\n        let dstByteIdx = start + ((x * h) >>> 1);\n\n        if (colStartBit === 0) {\n            // Fast path: aligned → copy byte-wise ได้เลย\n            // src[0] ไป nybble สูงของ byte แรก, src[1] ไป nybble ต่ำ, ฯลฯ\n            while (srcIdx < pixelCount - 1) {\n                fxpic[dstByteIdx] = (src[srcIdx] << 4) | (src[srcIdx + 1] & 0xF);\n                srcIdx += 2;\n                dstByteIdx++;\n            }\n            // เหลือพิกเซลสุดท้าย (ถ้า len เป็น odd)\n            if (srcIdx < pixelCount) {\n                fxpic[dstByteIdx] = (src[srcIdx] << 4) | (fxpic[dstByteIdx] & 0x0F);\n            }\n            return;\n        }\n        // Misaligned path: เริ่มจาก nybble ต่ำของ byte แรก\n        // จัดการ byte แรกแยก (merge กับ nybble เดิม)\n        if (srcIdx < pixelCount) {\n            fxpic[dstByteIdx] = (fxpic[dstByteIdx] & 0xF0) | (src[srcIdx] & 0xF);\n            srcIdx++;\n            dstByteIdx++;\n        }\n        // จากนั้น copy แบบ aligned เหมือน fast path\n        while (srcIdx < pixelCount - 1) {\n            fxpic[dstByteIdx] = (src[srcIdx] << 4) | (src[srcIdx + 1] & 0xF);\n            srcIdx += 2;\n            dstByteIdx++;\n        }\n        // เหลือตัวสุดท้าย (ถ้ามี)\n        if (srcIdx < pixelCount) {\n            fxpic[dstByteIdx] = (src[srcIdx] << 4) | (fxpic[dstByteIdx] & 0x0F);\n        }\n    }\n\n    export function fximgGetRows(fxpic: Buffer, x: number, dst: Buffer, h?: number) {\n        h = h || fximgHeightOf(fxpic);\n        const len = Math.min(dst.length, h);\n        if (len <= 0 || fximgIsOutOfRange(x, fximgWidthOf(fxpic) * fximgLengthOf(fxpic))) return;\n\n        const start = fximgStartIndex(fxpic);\n        const colStartBit = (x * h) & 1;\n        let dstIdx = 0;\n        let srcByteIdx = start + ((x * h) >>> 1);\n\n        if (colStartBit === 0) {\n            // Aligned: byte-wise extract\n            while (dstIdx < len - 1) {\n                const b = fxpic[srcByteIdx];\n                dst[dstIdx] = b >>> 4;\n                dst[dstIdx + 1] = b & 0xF;\n                dstIdx += 2;\n                srcByteIdx++;\n            }\n            if (dstIdx < len) {\n                dst[dstIdx] = fxpic[srcByteIdx] >>> 4;\n            }\n            return;\n        }\n        // Misaligned\n        if (dstIdx < len) {\n            dst[dstIdx] = fxpic[srcByteIdx] & 0xF;\n            dstIdx++;\n            srcByteIdx++;\n        }\n        while (dstIdx < len - 1) {\n            const b = fxpic[srcByteIdx];\n            dst[dstIdx] = b >>> 4;\n            dst[dstIdx + 1] = b & 0xF;\n            dstIdx += 2;\n            srcByteIdx++;\n        }\n        if (dstIdx < len) {\n            dst[dstIdx] = fxpic[srcByteIdx] >>> 4;\n        }\n    }\n\n    /* // Helper: clip ค่าให้อยู่ในช่วง\n    function clip(v: number, minv: number, maxv: number): number {\n        return v < minv ? minv : (v > maxv ? maxv : v);\n    } */\n\n    // 1. drawLine (Bresenham ปรับปรุงตามที่ภัทรแนะนำ - ใช้ sx/sy ตรวจทิศทาง ไม่เช็คจุดเริ่ม=จุดจบ)\n    export function fximgDrawLine(fxpic: Buffer, x0: number, y0: number, x1: number, y1: number, color: number, idx?: number) {\n        color &= 0xF;\n        if (x0 === x1 && y0 === y1) { fximgSetPixel(fxpic, x0, y0, color, idx); return; }\n        idx = idx || 0;\n        if (fximgIsOutOfRange(idx, fximgLengthOf(fxpic,))) return;\n        const w = fximgWidthOf(fxpic);\n        const h = fximgHeightOf(fxpic);\n        const iw = idx * w;\n        if ((x0 < 0 && x1 < 0) || (x0 >= w && x1 >= w) ||\n            (y0 < 0 && y1 < 0) || (y0 >= h && y1 >= h)) return;\n\n        let dx = Math.abs(x1 - x0);\n        let dy = Math.abs(y1 - y0);\n        let sx = Math.clamp(-1, 1, x1 - x0);\n        let sy = Math.clamp(-1, 1, y1 - y0);\n        let err = dx - dy;\n\n        while (1) {\n            if (((sx < 0 && x0 < 0) || (sx > 0 && x0 >= w) && sx !== 0) ||\n                ((sy < 0 && y0 < 0) || (sy > 0 && y0 >= h) && sy !== 0)) break;\n            fximgSetPixel(fxpic, x0 + iw, y0, color);\n\n            // ตรวจทิศทาง + เกินจุดหมายหรือยัง (ป้องกัน overflow)\n            if (((sx > 0 && x0 >= x1) || (sx < 0 && x0 <= x1) && sx !== 0) ||\n                ((sy > 0 && y0 >= y1) || (sy < 0 && y0 <= y1) && sy !== 0)) break;\n\n            let e2 = err << 1;\n            if (e2 > -dy) { err -= dy; x0 += sx; }\n            if (e2 < dx) { err += dx; y0 += sy; }\n        }\n    }\n\n    // 2. drawRect (ขอบ)\n    export function fximgDrawRect(fxpic: Buffer, x: number, y: number, width: number, height: number, color: number, idx?: number) {\n        if (width < 1 || height < 1) return;\n        fximgDrawLine(fxpic, x, y, x + width - 1, y, color, idx);\n        fximgDrawLine(fxpic, x + width - 1, y, x + width - 1, y + height - 1, color, idx);\n        fximgDrawLine(fxpic, x + width - 1, y + height - 1, x, y + height - 1, color, idx);\n        fximgDrawLine(fxpic, x, y + height - 1, x, y, color, idx);\n    }\n\n    // 3. fillRect (เติมเต็ม)\n    export function fximgFillRect(fxpic: Buffer, x: number, y: number, width: number, height: number, color: number, idx?: number) {\n        idx = idx || 0;\n        if (fximgIsOutOfRange(idx, fximgLengthOf(fxpic))) return;\n        const w = fximgWidthOf(fxpic) * fximgLengthOf(fxpic);\n        const h = fximgHeightOf(fxpic);\n        if (width < 1 || height < 1) return;\n        color &= 0xF;\n        idx *= w;\n\n        const sx = Math.clamp(0, w - 1, x);\n        const ex = Math.clamp(0, w - 1, x + width - 1);\n        const sy = Math.clamp(0, h - 1, y);\n        const ey = Math.clamp(0, h - 1, y + height - 1);\n        if (sx > ex || sy > ey) return;\n\n        const rowBuf = pins.createBuffer(h);\n        for (let cx = sx; cx <= ex; cx++) {\n            fximgGetRows(fxpic, cx + idx, rowBuf, h);\n            for (let cy = sy; cy <= ey; cy++) rowBuf[cy] = color;\n            fximgSetRows(fxpic, cx + idx, rowBuf, h);\n        }\n    }\n\n    // 4. fill (เติมทั้งภาพ)\n    export function fximgFill(fxpic: Buffer, color: number, idx?: number) {\n        idx = idx || 0;\n        if (idx, fximgLengthOf(fxpic)) return;\n        color &= 0xF;\n        const h = fximgHeightOf(fxpic);\n        const rowBuf = pins.createBuffer(h);\n        rowBuf.fill(color);\n        const w = fximgWidthOf(fxpic);\n        idx *= w;\n        for (let x = 0; x < w; x++) fximgSetRows(fxpic, idx + x, rowBuf, h);\n    }\n\n    // 5. replace (แทนที่สี)\n    export function fximgReplace(fxpic: Buffer, from: number, to: number, idx?: number) {\n        from &= 0xF; to &= 0xF;\n        idx = idx || 0;\n        if (fximgIsOutOfRange(idx, fximgLengthOf(fxpic))) return;\n        const w = fximgWidthOf(fxpic);\n        idx *= w;\n        const h = fximgHeightOf(fxpic);\n        const rowBuf = pins.createBuffer(h);\n        for (let x = 0; x < w; x++) {\n            fximgGetRows(fxpic, idx + x, rowBuf, h);\n            for (let y = 0; y < h; y++) if (rowBuf[y] === from) rowBuf[y] = to;\n            fximgSetRows(fxpic, idx + x, rowBuf, h);\n        }\n    }\n\n    // 6. drawCircle (midpoint circle - integer)\n    export function fximgDrawCircle(fxpic: Buffer, cx: number, cy: number, r: number, color: number, idx?: number) {\n        if (r < 1) return;\n        idx = idx || 0;\n        if (fximgIsOutOfRange(idx, fximgLengthOf(fxpic))) return;\n        color &= 0xF;\n        let x = r;\n        let y = 0;\n        let err = 1 - 2 * r;\n\n        while (x >= y) {\n            fximgSetPixel(fxpic, cx + x, cy + y, color, idx);\n            fximgSetPixel(fxpic, cx - x, cy + y, color, idx);\n            fximgSetPixel(fxpic, cx + x, cy - y, color, idx);\n            fximgSetPixel(fxpic, cx - x, cy - y, color, idx);\n            fximgSetPixel(fxpic, cx + y, cy + x, color, idx);\n            fximgSetPixel(fxpic, cx - y, cy + x, color, idx);\n            fximgSetPixel(fxpic, cx + y, cy - x, color, idx);\n            fximgSetPixel(fxpic, cx - y, cy - x, color, idx);\n\n            y++;\n            if (err <= 0) {\n                err += 2 * y + 1;\n            } else {\n                x--;\n                err += 2 * (y - x) + 1;\n            }\n        }\n    }\n\n    // 7. fillCircle (ใช้ drawLine แนวนอน)\n    export function fximgFillCircle(fxpic: Buffer, cx: number, cy: number, r: number, color: number, idx?: number) {\n        if (r < 1) return;\n        idx = idx || 0;\n        if (fximgIsOutOfRange(idx, fximgLengthOf(fxpic))) return;\n        color &= 0xF;\n        const h = fximgHeightOf(fxpic);\n        for (let dy = -r; dy <= r; dy++) {\n            let y = cy + dy;\n            if (y < 0 || y >= h) continue;\n            let dx = Math.sqrt(r * r - dy * dy) | 0;\n            fximgDrawLine(fxpic, cx - dx, y, cx + dx, y, color, idx);\n        }\n    }\n\n    // 8. drawOval (midpoint oval - integer)\n    export function fximgDrawOval(fxpic: Buffer, cx: number, cy: number, rx: number, ry: number, color: number, idx?: number) {\n        rx = Math.abs(rx); ry = Math.abs(ry);\n        if (rx === 0 || ry === 0) return;\n        if (rx === ry) { fximgDrawCircle(fxpic, cx, cy, rx, color, idx); return; }\n        idx = idx || 0;\n        if (fximgIsOutOfRange(idx, fximgLengthOf(fxpic))) return;\n\n        cy -= (ry >>> 1);\n        color &= 0xF;\n\n        let a = rx, b = ry;\n        let b1 = b & 1;             // odd radius correction\n\n        let dx = ((1 - a) << 2) * (b * b);\n        let dy = ((b1 + 1) << 2) * (a * a);\n        let err = dx + dy + b1 * a * a;\n\n        let x0 = cx - a, x1 = cx + a;\n        let y0 = cy + ((b + 1) >> 1);\n        let y1 = y0 - b1;\n\n        // Adjust left/right if rx odd\n        if (x0 > x1) { let t = x0; x0 = x1; x1 = t + a; }\n\n        a *= (a << 2);     // a = 4a²\n        b1 = (b * b) << 2; // b1 = 4b²\n\n        do {\n            fximgSetPixel(fxpic, x1, y0, color, idx);\n            fximgSetPixel(fxpic, x0, y0, color, idx);\n            fximgSetPixel(fxpic, x0, y1, color, idx);\n            fximgSetPixel(fxpic, x1, y1, color, idx);\n\n            let e2 = err << 1;\n\n            if (e2 <= dy) { y0++; y1--; err += dy += a; }     // y step\n            if (e2 >= dx || (err << 1) > dy) { x0++; x1--; err += dx += b1; } // x step\n\n        } while (x0 <= x1);\n\n        // Draw tips for very flat ellipses\n        while (y0 - y1 < b) {\n            fximgSetPixel(fxpic, x0 - 1, y0, color, idx);\n            fximgSetPixel(fxpic, x1 + 1, y0++, color, idx);\n            fximgSetPixel(fxpic, x0 - 1, y1, color, idx);\n            fximgSetPixel(fxpic, x1 + 1, y1--, color, idx);\n        }\n    }\n\n    // 9. fillOval\n    export function fximgFillOval(fxpic: Buffer, cx: number, cy: number, rx: number, ry: number, color: number, idx?: number) {\n        if (rx < 1 || ry < 1) return;\n        if (rx === ry) { fximgDrawCircle(fxpic, cx, cy, rx, color, idx); return; }\n        idx = idx || 0;\n        if (fximgIsOutOfRange(idx, fximgLengthOf(fxpic))) return;\n\n        color &= 0xF;\n        const h = fximgHeightOf(fxpic);\n        const ry2 = ry * ry;\n        for (let dy = -ry; dy <= ry; dy++) {\n            let y = cy + dy;\n            if (y < 0 || y >= h) continue;\n            let dx = Math.sqrt(rx * rx * (1 - (dy * dy / ry2))) | 0;\n            fximgDrawLine(fxpic, cx - dx, y, cx + dx, y, color, idx);\n        }\n    }\n\n    export function fximgEqualTo(fxpic: Buffer, to: Buffer) {\n        if (fxpic.length < 1 || to.length < 1) return false;\n        if (fxpic.length !== to.length) return false;\n        if (fximgWidthOf(fxpic) !== fximgWidthOf(to) ||\n            fximgHeightOf(fxpic) !== fximgHeightOf(to)) return false\n        return fxpic.equals(to);\n    }\n\n    // 10. copyFrom (copy ทั้ง buffer ถ้าขนาดเท่ากัน)\n    export function copyFrom(fxpic: Buffer, from: Buffer) {\n        const w = Math.min(fximgWidthOf(from), fximgWidthOf(fxpic));\n        const h = Math.min(fximgHeightOf(from), fximgHeightOf(fxpic))\n        if (w < 1 || h < 1) return;\n        if (from.length === fxpic.length) {\n            fxpic.write(0, from);\n            return;\n        }\n        const buf = pins.createBuffer(h);\n        for (let i = 0; i < w; i++) {\n            fximgGetRows(from, i, buf, h);\n            fximgSetRows(fxpic, i, buf, h);\n        }\n    }\n\n    // 11. clone\n    export function fximgClone(fxpic: Buffer): Buffer {\n        return fxpic.slice();\n    }\n\n    // 12. drawImage (ไม่ transparent)\n    export function fximgDrawImage(fxpic: Buffer, to: Buffer, dx: number, dy: number) {\n        fximgBulitDrawImage(fxpic, to, dx, dy, false);\n    }\n\n    // 13. drawTransparentImage (skip สี 0)\n    export function fximgDrawTransparentImage(fxpic: Buffer, to: Buffer, dx: number, dy: number) {\n        fximgBulitDrawImage(fxpic, to, dx, dy, true);\n    }\n\n    function fximgBulitDrawImage(from: Buffer, to: Buffer, dx: number, dy: number, transparent: boolean) {\n        const sw = fximgWidthOf(from)\n        const sh = fximgHeightOf(from);\n        const tw = fximgWidthOf(to)\n        const th = fximgHeightOf(to);\n\n        const rowFrom = pins.createBuffer(sh);\n        const rowTo = pins.createBuffer(th);\n        for (let sx = 0; sx < sw; sx++) {\n            let tx = dx + sx;\n            if (tx < 0) continue;\n            if (tx >= tw) break;\n\n            fximgGetRows(from, sx, rowFrom);\n            fximgGetRows(to, tx, rowTo);\n\n            for (let sy = 0; sy < sh; sy++) {\n                let ty = dy + sy;\n                if (ty < 0) continue;\n                if (ty >= th) break;\n                if (transparent && rowFrom[sy] < 1) continue;\n                if (rowTo[ty] === rowFrom[sy]) continue;\n                rowTo[ty] = rowFrom[sy];\n            }\n            fximgSetRows(to, tx, rowTo);\n        }\n    }\n\n    // 14. scale (nearest neighbor)\n    export function fximgScale(fxpic: Buffer, width: number, height: number): Buffer {\n        const ow = fximgWidthOf(fxpic);\n        const oh = fximgHeightOf(fxpic);\n        if (ow === width && oh === height) return fximgClone(fxpic);\n        const to = fximgCreate(width, height);\n        const toRowBuf = pins.createBuffer(height);\n        const fromRowBuf = pins.createBuffer(oh);\n\n        for (let x = 0; x < width; x++) {\n            let sx = Math.idiv(x * ow, width);\n            fximgGetRows(fxpic, sx, fromRowBuf, oh);\n            for (let y = 0; y < height; y++) {\n                let sy = Math.idiv(y * oh, height);\n                toRowBuf[y] = fromRowBuf[sy]\n            }\n            fximgSetRows(to, x, toRowBuf, height);\n        }\n        return to;\n    }\n\n    // 15. rotate90 (n90 = 1,2,3 → 90°,180°,270°)\n    export function fximgRotate90(fxpic: Buffer, n90: number): Buffer {\n        n90 = n90 & 0x3;\n        if (n90 === 0) return fximgClone(fxpic);\n\n        const w = fximgWidthOf(fxpic);\n        const h = fximgHeightOf(fxpic);\n        const nw = (n90 & 1) ? h : w;\n        const nh = (n90 & 1) ? w : h;\n        const dst = fximgCreate(nw, nh);\n\n        for (let y = 0; y < h; y++) {\n            for (let x = 0; x < w; x++) {\n                let c = fximgGetPixel(fxpic, x, y);\n                let nx: number, ny: number;\n                if (n90 === 1) { nx = y; ny = w - 1 - x; }\n                else if (n90 === 2) { nx = w - 1 - x; ny = h - 1 - y; }\n                else { nx = h - 1 - y; ny = x; }\n                fximgSetPixel(dst, nx, ny, c);\n            }\n        }\n        return dst;\n    }\n\n    // ค่า sin(theta * 2π / 256) * 127 (ประมาณ ±127) เพื่อให้เป็น int8-friendly\n    // แต่เก็บเป็น number (int16) เพื่อความแม่นยำในการคำนวณ\n    const sineTable: number[] = [\n        0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45,\n        48, 51, 54, 57, 59, 62, 65, 67, 70, 72, 75, 77, 80, 82, 84, 86,\n        88, 90, 92, 94, 96, 98, 99, 101, 102, 104, 105, 106, 108, 109, 110, 111,\n        112, 113, 114, 115, 115, 116, 117, 117, 118, 118, 119, 119, 119, 120, 120, 120,\n        120, 120, 120, 120, 119, 119, 119, 118, 118, 117, 117, 116, 115, 115, 114, 113,\n        112, 111, 110, 109, 108, 106, 105, 104, 102, 101, 99, 98, 96, 94, 92, 90,\n        88, 86, 84, 82, 80, 77, 75, 72, 70, 67, 65, 62, 59, 57, 54, 51,\n        48, 45, 42, 39, 36, 33, 30, 27, 24, 21, 18, 15, 12, 9, 6, 3,\n        0, -3, -6, -9, -12, -15, -18, -21, -24, -27, -30, -33, -36, -39, -42, -45,\n        -48, -51, -54, -57, -59, -62, -65, -67, -70, -72, -75, -77, -80, -82, -84, -86,\n        -88, -90, -92, -94, -96, -98, -99, -101, -102, -104, -105, -106, -108, -109, -110, -111,\n        -112, -113, -114, -115, -115, -116, -117, -117, -118, -118, -119, -119, -119, -120, -120, -120,\n        -120, -120, -120, -120, -119, -119, -119, -118, -118, -117, -117, -116, -115, -115, -114, -113,\n        -112, -111, -110, -109, -108, -106, -105, -104, -102, -101, -99, -98, -96, -94, -92, -90,\n        -88, -86, -84, -82, -80, -77, -75, -72, -70, -67, -65, -62, -59, -57, -54, -51,\n        -48, -45, -42, -39, -36, -33, -30, -27, -24, -21, -18, -15, -12, -9, -6, -3\n    ];\n\n    function iSin(theta: number): number {\n        return sineTable[theta & 0xFF];\n    }\n\n    function iCos(theta: number): number {\n        return sineTable[(theta + 64) & 0xFF];  // cos = sin + 90° (64 ใน 256)\n    }\n\n    function fximgRotatedBounds(width: number, height: number, theta: number): number[] {\n        let s = Math.abs(iSin(theta));   // |sin| * 120\n        let c = Math.abs(iCos(theta));   // |cos| * 120\n\n        // newW ≈ (|cos| * w + |sin| * h) / 120 + 1 (เผื่อ margin)\n        let newW = Math.idiv(c * width + s * height, 120) + 1;\n        let newH = Math.idiv(s * width + c * height, 120) + 1;\n\n        // เพิ่ม margin เล็กน้อยเพื่อป้องกัน clipping จาก rounding\n        newW += 2;\n        newH += 2;\n\n        return [newW, newH];\n    }\n\n    // 16. rotate (theta 0-255 ด้วย sin/cos table)\n    export function fximgRotate(fxpic: Buffer, theta: number): Buffer {\n        const ow = fximgWidthOf(fxpic)\n        const oh = fximgHeightOf(fxpic);\n\n        // หาขนาด bounding box ใหม่\n        const [nw, nh] = fximgRotatedBounds(ow, oh, theta);\n\n        // สร้าง Buffer ใหม่ขนาดใหญ่ขึ้น\n        const dst = fximgCreate(nw, nh);\n        //fill(dst, 0);  // พื้นหลังโปร่งใส (สี 0)\n\n        // จุดกึ่งกลางใหม่ (สำหรับวางภาพเก่าตรงกลาง)\n        const dstCx = nw >> 1;\n        const dstCy = nh >> 1;\n        const srcCx = ow >> 1;\n        const srcCy = oh >> 1;\n\n        const s = iSin(theta);\n        const c = iCos(theta);\n\n        // วาดทุกพิกเซลจาก dst → map กลับไป src (reverse rotation เพื่อ fill hole)\n        // หรือ forward จาก src → dst (แบบเดิม แต่ shift offset)\n        for (let dy = -dstCy; dy < nh - dstCy; dy++) {\n            for (let dx = -dstCx; dx < nw - dstCx; dx++) {\n                // dx, dy คือ offset จาก center ใหม่\n                let ox = Math.idiv(dx * c - dy * s, 120);\n                let oy = Math.idiv(dx * s + dy * c, 120);\n\n                let sx = ox + srcCx;\n                let sy = oy + srcCy;\n\n                if (sx < 0 || sx >= ow || sy < 0 || sy >= oh) continue;\n                let col = fximgGetPixel(fxpic, sx, sy);\n                if (col < 1) continue;  // skip transparent\n                let tx = dx + dstCx;\n                let ty = dy + dstCy;\n                fximgSetPixel(dst, tx, ty, col);\n            }\n        }\n        return dst;\n    }\n\n    // 17. rotationFrame (สร้างหลายเฟรมหมุนเท่า ๆ กัน)\n    export function fximgRotationFrame(fxpic: Buffer, count: number): Buffer {\n        if (count < 1) count = 1;\n        const step = Math.idiv(256, count);\n        let w = fximgWidthOf(fxpic)\n        let h = fximgHeightOf(fxpic);\n        const [bw, bh] = fximgRotatedBounds(w, h, 32);\n        const [bw2, bh2] = [bw << 1, bh << 1]\n        const bigBuf = fximgCreateFrame(w + bw2, h + bh2, count);\n\n        let offset = 0;\n        for (let i = 0; i < count; i++) {\n            const [nw, nh] = fximgRotatedBounds(w, h, i * step);\n            let frame = fximgRotate(fxpic, i * step);\n            fximgDrawTransparentImage(bigBuf, frame, offset + Math.abs(bw - nw), Math.abs(bh - nh));\n            offset += w + bw2;\n        }\n        return bigBuf;\n    }\n\n    // Optional: trim ขอบโปร่งใส (สี 0) ออกให้เหลือเฉพาะส่วนที่มีเนื้อหา\n    export function fximgTrim(fxpic: Buffer): Buffer {\n        const w = fximgWidthOf(fxpic);\n        const h = fximgHeightOf(fxpic);\n        if (w <= 0 || h <= 0) return fximgCreate(1, 1);\n\n        const rowBuf = pins.createBuffer(h);\n\n        // หา leftmost column ที่มี non-zero\n        let minX = w;\n        for (let x = 0; x < w; x++) {\n            fximgGetRows(fxpic, x, rowBuf, h);\n            for (let y = 0; y < h; y++) {\n                if (rowBuf[y] !== 0) {\n                    minX = x;\n                    break;\n                }\n            }\n            if (minX < w) break;  // พบแล้ว หยุด scan ต่อ\n        }\n\n        // หา rightmost column\n        let maxX = -1;\n        for (let x = w - 1; x >= minX; x--) {\n            fximgGetRows(fxpic, x, rowBuf, h);\n            for (let y = 0; y < h; y++) {\n                if (rowBuf[y] !== 0) {\n                    maxX = x;\n                    break;\n                }\n            }\n            if (maxX >= 0) break;\n        }\n\n        if (maxX < minX) return fximgCreate(1, 1); // ว่างทั้งหมด\n\n        // หา topmost row (scan เฉพาะช่วง minX..maxX)\n        let minY = h;\n        const colBuf = pins.createBuffer(maxX - minX + 1);\n        for (let y = 0; y < h; y++) {\n            // อ่านเฉพาะช่วง x ที่มีเนื้อหา\n            for (let x = minX; x <= maxX; x++) colBuf[x - minX] = fximgGetPixel(fxpic, x, y);  // หรือ optimize ด้วย getRows แล้ว slice\n            for (let i = 0; i < colBuf.length; i++) {\n                if (colBuf[i] !== 0) {\n                    minY = y;\n                    break;\n                }\n            }\n            if (minY < h) break;\n        }\n\n        // หา bottommost row\n        let maxY = -1;\n        for (let y = h - 1; y >= minY; y--) {\n            for (let x = minX; x <= maxX; x++) colBuf[x - minX] = fximgGetPixel(fxpic, x, y);\n            for (let i = 0; i < colBuf.length; i++) {\n                if (colBuf[i] !== 0) {\n                    maxY = y;\n                    break;\n                }\n            }\n            if (maxY >= 0) break;\n        }\n\n        const newW = maxX - minX + 1;\n        const newH = maxY - minY + 1;\n        const trimmed = fximgCreate(newW, newH);\n\n        // copy เฉพาะส่วนที่เหลือ\n        for (let x = minX; x <= maxX; x++) {\n            fximgGetRows(fxpic, x, rowBuf, h);\n            fximgSetRows(trimmed, x - minX, rowBuf, newH);  // ตัดส่วนบนล่างอัตโนมัติเพราะ setRows ใช้ len = newH\n        }\n\n        return trimmed;\n    }\n\n    // คืน bounding box ที่ clip กับภาพแล้ว [minX, maxX, minY, maxY]\n    function fximgGetClippedBounds(\n        fxpic: Buffer,\n        xCoords: number[],  // x ของจุดต่าง ๆ\n        yCoords: number[]   // y ของจุดต่าง ๆ\n    ): number[] {\n        const totalW = fximgWidthOf(fxpic) * fximgLengthOf(fxpic);\n        const h = fximgHeightOf(fxpic);\n\n        let minX = totalW;\n        let maxX = -1;\n        let minY = h;\n        let maxY = -1;\n\n        for (let i = 0; i < xCoords.length; i++) {\n            const x = Math.clamp(0, totalW - 1, xCoords[i]);\n            const y = Math.clamp(0, h - 1, yCoords[i]);\n            minX = Math.min(minX, x);\n            maxX = Math.max(maxX, x);\n            minY = Math.min(minY, y);\n            maxY = Math.max(maxY, y);\n        }\n\n        if (minX > maxX || minY > maxY) return [0, -1, 0, -1]; // ว่าง\n        return [minX, maxX, minY, maxY];\n    }\n\n    // manual sort 3 จุดตาม x (คืน index เรียงจาก x น้อย → มาก)\n    function fximgSortTrianglePointsByX(\n        x0: number, y0: number,\n        x1: number, y1: number,\n        x2: number, y2: number\n    ): number[] {  // คืน [idxA, idxB, idxC] โดย xA <= xB <= xC\n        if (x0 <= x1 && x0 <= x2) {\n            if (x1 <= x2) return [0, 1, 2];\n            return [0, 2, 1];\n        }\n        if (x1 <= x0 && x1 <= x2) {\n            if (x0 <= x2) return [1, 0, 2];\n            return [1, 2, 0];\n        }\n        // x2 เป็น min\n        if (x0 <= x1) return [2, 0, 1];\n        return [2, 1, 0];\n    }\n\n    export function fximgFillTriangle(\n        fxpic: Buffer,\n        x0: number, y0: number,\n        x1: number, y1: number,\n        x2: number, y2: number,\n        color: number, idx?: number\n    ) {\n        idx = idx || 0;\n        if (fximgIsOutOfRange(idx, fximgLengthOf(fxpic))) return;\n\n        color &= 0xF;\n        const w = fximgWidthOf(fxpic);\n        const h = fximgHeightOf(fxpic);\n        if (fximgIsOutOfAreas([{ x: x0, y: y0 }, { x: x1, y: y1 }, { x: x2, y: y2 }], w, h)) return;\n        idx *= w;\n\n        // bounding box clip\n        const [minX, maxX, minY, maxY] = fximgGetClippedBounds(fxpic, [x0, x1, x2], [y0, y1, y2]);\n        if (minX > maxX) return;\n\n        // manual sort จุดตาม x\n        const order = fximgSortTrianglePointsByX(x0, y0, x1, y1, x2, y2);\n        const xs = [x0, x1, x2];\n        const ys = [y0, y1, y2];\n        const xa = xs[order[0]], ya = ys[order[0]];\n        const xb = xs[order[1]], yb = ys[order[1]];\n        const xc = xs[order[2]], yc = ys[order[2]];\n\n        const rowBuf = pins.createBuffer(h);\n\n        for (let x = Math.max(0, minX | 0); x <= Math.min(w - 1, maxX | 0); x++) {\n            fximgGetRows(fxpic, idx + x, rowBuf, h);\n\n            // หา y range สำหรับ x นี้ (intersect กับ 3 ขอบ)\n            let yStart = h;\n            let yEnd = -1;\n\n            // ขอบ AB\n            if (xa !== xb) {\n                const t = (x - xa) / (xb - xa);\n                if (t >= 0 && t <= 1) {\n                    const yab = ya + t * (yb - ya);\n                    yStart = Math.min(yStart, yab);\n                    yEnd = Math.max(yEnd, yab);\n                }\n            }\n\n            // ขอบ AC\n            if (xa !== xc) {\n                const t = (x - xa) / (xc - xa);\n                if (t >= 0 && t <= 1) {\n                    const yac = ya + t * (yc - ya);\n                    yStart = Math.min(yStart, yac);\n                    yEnd = Math.max(yEnd, yac);\n                }\n            }\n\n            // ขอบ BC (เฉพาะเมื่อ x อยู่ระหว่าง xb กับ xc)\n            if (xb !== xc && x >= Math.min(xb, xc) && x <= Math.max(xb, xc)) {\n                const t = (x - xb) / (xc - xb);\n                const ybc = yb + t * (yc - yb);\n                yStart = Math.min(yStart, ybc);\n                yEnd = Math.max(yEnd, ybc);\n            }\n\n            if (yStart <= yEnd) {\n                const clipYStart = Math.max(minY, Math.ceil(yStart));\n                const clipYEnd = Math.min(maxY, Math.floor(yEnd));\n                for (let y = clipYStart; y <= clipYEnd; y++) if (rowBuf[y] !== color) rowBuf[y] = color;\n                fximgSetRows(fxpic, idx + x, rowBuf, h);\n            }\n        }\n    }\n\n    export function fximgFillPolygon4(\n        fxpic: Buffer,\n        x0: number, y0: number,\n        x1: number, y1: number,\n        x2: number, y2: number,\n        x3: number, y3: number,\n        color: number, idx?: number\n    ) {\n        fximgFillTriangle(fxpic, x0, y0, x1, y1, x2, y2, color, idx);\n        fximgFillTriangle(fxpic, x3, y3, x1, x1, y2, y2, color, idx);\n    }\n\n    export function fximgDrawDistortedImage(\n        fxpic: Buffer, to: Buffer,\n        x0: number, y0: number,\n        x1: number, y1: number,\n        x2: number, y2: number,\n        x3: number, y3: number,\n    ) {\n        fximgBuiltDrawDistortedImage(\n            fxpic, to,\n            x0, y0, x1, y1,\n            x2, y2, x3, y3,\n            false\n        )\n    }\n\n    export function fximgDrawTransDistortedImage(\n        fxpic: Buffer, to: Buffer,\n        x0: number, y0: number,\n        x1: number, y1: number,\n        x2: number, y2: number,\n        x3: number, y3: number,\n    ) {\n        fximgBuiltDrawDistortedImage(\n            fxpic, to,\n            x0, y0, x1, y1,\n            x2, y2, x3, y3,\n            true\n        )\n    }\n\n    const fximgZigzet = (l: number, r: number, n: number, c?: boolean) => {\n        if (l + n > r) return NaN;\n        const size = (r - l);\n        const n2 = n >>> 1;\n        const half = (c ? 0.5 : 0)\n        if (n % 2 > 0) return l + (n2 + half);\n        return l + (size - n2 - half);\n    }\n\n    function fximgBuiltDrawDistortedImage(\n        src: Buffer, dst: Buffer,\n        x0: number, y0: number,  // top-left\n        x1: number, y1: number,  // top-right\n        x2: number, y2: number,  // bottom-right\n        x3: number, y3: number,  // bottom-left\n        transparent: boolean,\n    ) {\n        const srcW = fximgWidthOf(src);\n        const srcH = fximgHeightOf(src);\n        const dstTotalW = fximgWidthOf(dst) * fximgLengthOf(dst);\n        const dstH = fximgHeightOf(dst);\n\n        const srcRow = pins.createBuffer(srcH);\n\n        // Precompute inverse เพื่อความเร็ว\n        const srcInvW = 1 / srcW;\n        const srcInvH = 1 / srcH;\n\n        for (let ix = srcW - 1; ix > -1; ix--) {\n            const sx = fximgZigzet(0, srcW - 1, ix);\n            fximgGetRows(src, sx, srcRow, srcH);\n\n            // u สำหรับ column นี้ (left edge) และ column ถัดไป (right edge)\n            const u0 = sx * srcInvW, u1 = (sx + 1) * srcInvW;\n\n            // คำนวณตำแหน่ง 4 มุมของ quad เล็ก ๆ ใน dst สำหรับ texel นี้\n            const qu0 = { x: x0 + (x1 - x0) * u0, y: y0 + (y1 - y0) * u0 };\n            const qu2 = { x: x0 + (x1 - x0) * u1, y: y0 + (y1 - y0) * u1 };\n            const qu1 = { x: x3 + (x2 - x3) * u0, y: y3 + (y2 - y3) * u0 };\n            const qu3 = { x: x3 + (x2 - x3) * u1, y: y3 + (y2 - y3) * u1 };\n\n            for (let iy = srcH - 1; iy > -1; iy--) {\n                const sy = fximgZigzet(0, srcH - 1, iy)\n                const color = srcRow[sy];\n                if (transparent && color < 1) continue;\n\n                // v สำหรับ row นี้ และ row ถัดไป\n                const v0 = sy * srcInvH, v1 = (sy + 1) * srcInvH;\n\n                // คำนวณ 4 จุดสุดท้ายของ quad ใน dst\n                const q0 = {  // top-left\n                    x: Math.round(qu0.x + (qu1.x - qu0.x) * v0),\n                    y: Math.round(qu0.y + (qu1.y - qu0.y) * v0)\n                };\n                const q1 = {  // top-right\n                    x: Math.round(qu2.x + (qu3.x - qu2.x) * v0),\n                    y: Math.round(qu2.y + (qu3.y - qu2.y) * v0)\n                };\n                const q2 = {  // bottom-right\n                    x: Math.round(qu0.x + (qu1.x - qu0.x) * v1),\n                    y: Math.round(qu0.y + (qu1.y - qu0.y) * v1)\n                };\n                const q3 = {  // bottom-left\n                    x: Math.round(qu2.x + (qu3.x - qu2.x) * v1),\n                    y: Math.round(qu2.y + (qu3.y - qu2.y) * v1)\n                };\n\n                const quad = [q0, q1, q2, q3];\n\n                // ถ้าทั้ง 4 จุดอยู่นอก → ข้าม\n                if (fximgIsOutOfAreas(quad, dstTotalW, dstH)) continue;\n\n                // วาด quad เล็ก ๆ ด้วย 2 triangle (หรือใช้ fillQuad ถ้ามี)\n                fximgFillTriangle(dst, q1.x, q1.y, q0.x, q0.y, q3.x, q3.y, color);\n                fximgFillTriangle(dst, q2.x, q2.y, q0.x, q0.y, q3.x, q3.y, color);\n            }\n        }\n    }\n}\n"}]}],"snapshots":[{"timestamp":1770987831892,"editorVersion":"2.0.63","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>","main.ts":" ","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"arcade-image-fixed\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1770988171573}